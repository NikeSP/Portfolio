# Задание: "Перевёрнутая башня"
#
# Вавилонцы решили построить удивительную башню —
# расширяющуюся к верху и содержащую бесконечное число этажей и комнат.
# Она устроена следующим образом — на первом этаже одна комната,
# затем идет два этажа, на каждом из которых по две комнаты,
# затем идёт три этажа, на каждом из которых по три комнаты и так далее:
#         ...
#     12  13  14
#     9   10  11
#     6   7   8
#       4   5
#       2   3
#         1
#
# Эту башню решили оборудовать лифтом --- и вот задача:
# нужно научиться по номеру комнаты определять,
# на каком этаже она находится и какая она по счету слева на этом этаже.
#
# Входные данные: В первой строчке задан номер комнаты N, 1 ≤ N ≤ 2 000 000 000.
#
# Выходные данные:  Два целых числа — номер этажа и порядковый номер слева на этаже.
#
# Пример:
# Вход: 13
# Выход: 6 2
#
# Вход: 11
# Выход: 5 3

# Решение:
# Формула корней кубического уравнения
# x3+a*x2+b*x+c=0.
# y3 + py + q = 0 формула Кардано
def cube(a: float, b: float, c: float):
    p = b - (a ** 2) / 3
    q = 2 * (a / 3) ** 3 - a * b / 3 + c
    Q = (p / 3) ** 3 + (q / 2) ** 2
    A = (-q / 2 + Q ** (1 / 2)) ** (1 / 3)
    B = (-q / 2 - Q ** (1 / 2)) ** (1 / 3)
    y_1 = A + B
    x_1 = y_1 - a / 3
    return x_1


# Правые вершины-x этажей-n подчиняются следующему закону
# n = 1  x =  1 = 1**2
# n = 2  x =  5 = 1**2 + 2**2
# n = 3  x = 14 = 1**2 + 2**2 + 3**2
# x[n] = x[n-1] + n**2
# Нижняя функция считает x(n)
def num_x(n: int) -> int:
    return round((n * (n + 1) * (2 * n + 1)) / 6)


# Аналитический метод вычисления
def position_x(x: int):
    if x <= 0:
        print('Недопустимый ввод')
        return False
    # 1. Функция обратная функции num_x(n) с точностью до единицы определят квадрат n x n в котором находится число
    n = round(cube(1.5, 0.5, -3 * x))
    # Уточняем квадрат в котором находится x
    n_ls = (n - 1, n, n + 1)
    x_ls = (num_x(n - 1), num_x(n), num_x(n + 1))
    # Проверяем вершины 3-х квадратов, если х находится в одной из них возвращаем ответ
    if x_ls.count(x) != 0:
        index_x = x_ls.index(x)
        # 2. Зная n можешь вычислить этаж и комнату, первый этаж - один, вторых - два, n-ных n,
        # сумма - сумма членов арифметической прогрессии
        level_amount = round(n_ls[index_x] * (n_ls[index_x] + 1) / 2)
        left = n_ls[index_x]
        return level_amount, left

    if x > x_ls[1]:
        ind = 2
    else:
        ind = 1
    # Мы точно знаем в каком квадрате лежит x перходим к задаче 3
    # 3. Определим положение в рамках квадрата n x n
    n_max = n_ls[ind]
    x_min = x_ls[ind - 1]
    n_min = n_ls[ind - 1]
    level_0 = round(n_min * (n_min + 1) / 2)
    temp = x - x_min
    level_local = (temp - 1) // n_max + 1
    left = temp - (level_local - 1) * n_max
    level_amount = level_0 + level_local
    return level_amount, left


# Сопоставление двух методов, последовательным и аналитическим вычислением
def test_num(border):
    number = 0
    level_amount = 0
    for i in range(1, border):
        for level_local in range(1, i + 1):
            level_amount += 1
            for left in range(1, i + 1):
                number += 1
                test_result = (position_x(number) == (level_amount, left))
                print(number, level_amount, left, test_result)


test_num(10)
# 41541750 124750 499 - эти значения получил за продолжительное время циклом перебора
print(2 * 10 ** 9, position_x(2 * 10 ** 9))
print(41541750, position_x(41541750))
