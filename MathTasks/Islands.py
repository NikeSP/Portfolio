# Условие:
#
#     Предположим, в один прекрасный день вы оказались на острове прямоугольный формы.
#     Ландшафт этого острова можно описать с помощью целочисленной матрицы размером MxN,
# каждый элемент которой задаёт высоту соответствующей области острова над уровнем моря.
#
#     К примеру, вот небольшой остров размером 3x3:
#     4 5 4
#     3 1 5
#     5 4 1
#
#     В сезон дождей остров полностью заливает водой и в низинах скапливается вода.
# Низиной будем считать такую область острова, клетки которой граничат с клетками,
# большими по высоте. При этом диагональные соседи не учитываются, а уровень моря принимается за 0.
# В приведённом выше примере на острове есть только одна низина — это клетка со значением 1
# в середине острова (она граничит с клетками высотой 3, 5, 5 и 4).
#
#     Таким образом, после дождя высота клеток острова изменится и станет следующей:
#     4 5 4
#     3 3 5
#     5 4 1
#
#     Мы видим что в данном примере высота низины изменилась с 1 до 3, после чего вода начала
# переливаться на соседние клетки, а затем — в море. Общий объём воды,
# скопившейся на острове — 2 кубические клетки.
#
#     Вот пример посложнее:
#
#     5 3 4 5
#     6 2 1 4
#     3 1 1 4
#     8 5 4 3
#
#     После дождя карта острова принимает следующую форму:
#
#     5 3 4 5
#     6 3 3 4
#     3 3 3 4
#     8 5 4 3
#
#     Общий объём скопившейся после дождя воды на таком острове составляет целых 7 кубических клеток!
#
#     Ваша программа должна быть по одному из шаблонов ниже.
#     На вход функции подается массив массивов, на выходе ожидается int - значения общего объёма воды,
# скапливающейся на острове после сезона дождей для каждого из входных примеров
#
#     Ограничения:
#     Размер острова N и M — целые числа в диапазоне [1, 50]
#     Высоты на острове могут принимать значения из диапазона [1, 1000].
#
#     Вот примеры входных данных:
#
#     4 5 4
#     3 1 5
#     5 4 1
#
#     5 3 4 5
#     6 2 1 4
#     3 1 1 4
#     8 5 4 3
#
#     2 2 2
#     2 1 2
#     2 1 2
#     2 1 2
#
#     Для приведённых выше данных, результат функции программы должен быть следующим:
#
#     2
#     7
#     0

# island is a list of lists
#  island = [
#      [2, 2, 2],
#      [2, 1, 2],
#      [2, 1, 2],
#      [2, 1, 2]
#  ]
# шаблон
# def get_water_volume(island):
#     # TODO
#     return 0


# import timeit
# import random


def get_water_volume(island: list) -> int:
    # Размеры острова
    i_size, j_size = len(island), len(island[0])

    if i_size < 3 or j_size < 3:
        return 0

    # Потенциально возможные низины, в начале берем матрица минус периметр
    n_points = set([(i, j) for i in range(1, i_size - 1) for j in range(1, j_size - 1)])

    # Граничные точки, в начале задаём, как периметр минус угловые точки
    g_points, g_values = [], []
    for i in range(1, i_size - 1):
        g_points += ((i, 0), (i, j_size - 1))
        g_values += (island[i][0], island[i][j_size - 1])
    for j in range(1, j_size - 1):
        g_points += ((0, j), (i_size - 1, j))
        g_values += (island[0][j], island[i_size - 1][j])

    # Объём воды скопившийся воды, в начале берём 0.
    water_volume = 0

    iteration, ind_to_comp = set(), set()
    while n_points:
        river = min(g_values)
        while g_values.count(river) > 0:
            ind = g_values.index(river)
            iteration.add(g_points.pop(ind))
            g_values.pop(ind)

        while iteration:
            while iteration:
                ind_i, ind_j = iteration.pop()
                ind_to_comp.update([(ind_i - 1, ind_j), (ind_i + 1, ind_j),
                                    (ind_i, ind_j - 1), (ind_i, ind_j + 1)])
            ind_to_comp &= n_points
            n_points -= ind_to_comp

            while ind_to_comp:
                ind_i, ind_j = ind_to_comp.pop()
                if island[ind_i][ind_j] <= river:
                    water_volume += river - island[ind_i][ind_j]
                    iteration.add((ind_i, ind_j))
                else:
                    g_points.append((ind_i, ind_j))
                    g_values.append(island[ind_i][ind_j])

    return water_volume


island_default = [
    [85, 88, 69, 26, 5, 56, 67, 30],
    [37, 32, 5, 34, 61, 96, 25, 7],
    [66, 1, 80, 94, 57, 67, 84, 2],
    [46, 32, 48, 35, 39, 21, 13, 61],
    [45, 15, 84, 71, 37, 74, 23, 4],
    [21, 42, 45, 15, 73, 15, 96, 78],
    [20, 2, 99, 97, 13, 16, 41, 33],
    [44, 31, 91, 93, 31, 81, 85, 45],
    [62, 93, 87, 69, 29, 34, 23, 55]
]

print(get_water_volume(island_default))

# Дальше идут материалы для тестирования

# island = [
#      [5, 3, 4, 6, 5, 9],
#      [6, 4, 1, 8, 7, 5],
#      [3, 2, 1, 8, 3, 7],
#      [8, 5, 4, 4, 6, 8]
# ]

# island = [
#      [2, 2, 2],
#      [2, 1, 2],
#      [2, 1, 2],
#      [2, 1, 2]
# ]

# island=[[2,6,4],[8,3,5],[2,7,6]]


# island = [
#     [85, 88, 69, 26, 5, 56, 67, 30],
#     [37, 81, 85, 84, 81, 96, 85, 7],
#     [66, 82, 80, 94, 57, 67, 84, 2],
#     [46, 83, 48, 35, 39, 21, 83, 61],
#     [45, 84, 84, 15, 37, 74, 83, 4],
#     [21, 85, 45, 35, 73, 15, 96, 78],
#     [20, 86, 99, 97, 85, 86, 81, 33],
#     [44, 31, 91, 93, 31, 81, 85, 45],
#     [62, 93, 87, 69, 29, 34, 23, 55]
# ]


# m = 20 + int(30 * random.random())
# n = 20 + int(30 * random.random())
# m = 50
# n = 50
# island = [[] for i in range(m)]
#
# for i in range(m):
#     for j in range(n):
#         island[i].append(int(1000 * random.random()))

# print(timeit.timeit('get_water_volume(island)', globals=globals(), number=5))

# print(m, n)
# print(get_water_volume(island))
